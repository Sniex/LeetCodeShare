# [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

### 题目：

> 一个机器人位于一个 m x n 网格的左上角 （起始点在\[0\]\[0\]）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（终点在\[m\]\[n\]）。
>
> 问总共有多少条不同的路径？



### 题解：

#### 1. 排列组合

> 因为限定了走路方式（重要！成立的前提），从0，0 到 m，n一定要走 m + n 步，所以可以求一下排列组合，C(n,n + m)

#### 2. 动态规划

>核心思想分解子问题， 根据题意，到达\[i\]\[j\]有2种方式，从\[i - 1\]\[j\]右移一步或从\[i\]\[j - 1\]下移一步，
>
>所以我们维护一个和地图一样大小的二维数组，在对应位置填上从\[0\]\[0\]到\[i\]\[j\]有多少不同路径。
>
>综上所述，arr\[i\]\[j\] = arr\[i - 1\]\[j\] + arr\[i\]\[j - 1\];  

##### 代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] arr = new int[m][n];
        arr[0][0] = 1; 
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0) {
                    arr[i][j] += arr[i - 1][j];
                }
                if (j > 0) {
                    arr[i][j] += arr[i][j - 1];
                }
            }
        }
        return arr[m -1][n - 1];
    }
}
```



#### 3. 编程技巧 --- 降维打击

> 2中的实现方式可以手动模拟跑一遍，我们发现，在维护二维数组更新\[i\]\[j\]的时候，
>
> \[i - 1\]\[j - 1\]这个值是没用的，我们用\[i - 1\]\[j\]和\[i\]\[j - 1\]的值相加求出\[i\]\[j\]，求完后，\[i - 1\]\[j\]的值也不会再被用到
>
> 所以我们可以把\[i\]\[j\]的值存在[i - 1\]\[j\]里 
>
> 如果这么做，那么在求[i\]\[j - 1\]的时候，\[i\]\[j - 1\]就存到了\[i - 1\]\[j - 1\] 里
>
> 所以\[i\]\[j\] = \[i - 1\]\[j - 1\] + [i - 1\]\[j\] 
>
> 又因为 我们要把\[i\]\[j\]的值存在[i - 1\]\[j\]里
>
> 所以  [i - 1\]\[j\] = \[i - 1\]\[j - 1\] + [i - 1\]\[j\]  
>
> 所以[i - 1] 失去了意义，降维打击成功
>
> 而且最终只有最后一个值是有用的，所以我们可以通过降维打击的方式节省空间（二维数组变一维）



|  1   |  1   |  1   |  1   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |  4   |  5   |  6   |
|  1   |  3   |  6   |  10  |  15  |  21  |
|  1   |  4   |  10  |  20  |  35  |  56  |

##### 代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] arr = new int[n];
        arr[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ( j > 0) {
                arr[j] += arr[j - 1];
                }
            }
        }
        return arr[n - 1];
    }
}
```

