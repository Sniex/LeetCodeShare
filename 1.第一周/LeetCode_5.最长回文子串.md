# LeetCode 5.[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

#### 题目：

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

#### 题目分析：

该题使用经典马拉车算法，专治最长回文子串，O(N)时间复杂度。

#### 算法讲解：

学习算法前，我们一起确认几个事情：

1. 在做回文串题时，奇数偶数的个数是个非常棘手的问题，通常情况下长度为奇数和偶数是要写两部分逻辑分别判断的，那我们假设字符串中不会出现符号#，我们在每两个字符中间都插入一个#，这样字符串长度一定为基数。

   因为在小学二年级的时候我们都知道  1. 奇数 + 偶数 = 奇数 2.偶数个数中间有奇数个空，奇数个数中间有偶数个空，所以原字符串长度加上符号#的个数，一定是奇数。 

   以上，我们将字符串长度固定为了奇数。此外我们又在字符串头额外加入了$和字符串尾加入了^，这个是编程技巧，加入了两个不相等的字符，方便程序判断终止。

2. 首先明确目的，我们的思路是求出以**每一个字符为回文串对称中心的最长回文串长度半径**，假设，我们有如下回文串

   > $ # a # b # c **<u>#</u>** c # b # a # ^ 
   >
   > 0 0 1 0 1 0 1 6 1 0 1 0 1 0 0

​      我们找到对称中心**<u>#</u>**，如果我们已知，以左侧的b为中心对称展开的最长回文串半径是1（#b#），那么与之对称的右侧的b最长回文半径也是1。（因为对称）

3. 但是在某些情况下，2不成立。我们有如下回文串

   > $ # b <u># a # b # c **#** c # b # a #</u> ^ (下划线标出部分为最长回文子串)
   >
   > 0 0 1 0 3 0 1 0 1 6 1 0 1 0 1 0 0

   我们发现，以**<u>#</u>**为对称中心的两个a，以他们为回文串对称中心的最长回文串半径并不相等，原因是，以左a为对称中心的回文串长度范围超出了以**<u>#</u>**为对称中心范围，我们结论2利用的是回文串的对称性，可是这里，左a的回文串已经超出了**<u>#</u>**的回文串的范围，特性自然就失效了，但是在**<u>#</u>**范围内的对称性是没失效的，所以我们可以从**x的对称位置的最长回文串半径**和**目前对称中心的最右侧 - 当前x的下标**两者中取较小值。

​       至此，我们就能运用以上结论，从左到右求出以**每一个字符为回文串对称中心的最长回文串长度半径**，重复利用之前的结果，来更快速的计算出当前下标所对应的值。

​        在实际编码中需要注意，以上例子都是建立在固定例子里，我们实际求解的时候，字符串右侧还有好长一段，所以，当我们通过捷径快速求出的x的回文半径，其实都是x的回文半径最小值，还需要近一步通过中心展开求出真正长度。同时记录一个目前“手最长的对称中心”（回文串最右侧下标最大的），用来充当上文的 **<u>#</u>**。

#### 附件：java代码

```java
class Solution {
    // 初始化马拉车字符串
    private String preprocess(String str) {
        StringBuffer sb = new StringBuffer("$");
        for (int i = 0; i < str.length(); i++) {
            sb.append("#").append(str.charAt(i));
        }
        return sb.append("#^").toString();
    }
    public String longestPalindrome(String str) {
        String sstr = preprocess(str);
        int[] arr = new int[sstr.length()];
        int c = 0;//目前使用的中心点
        int s = 0;//以c为中心的最长回文串 i的对称点  既 s + i = 2c
        int r = 0;//以c为中心的最长回文串 最右侧的下标
        int maxLen = 0;
        int maxInd = 0;
        for (int i = 1; i < arr.length - 1; i++) {
            s = c * 2 - i;
            if (r > i) {
                arr[i] = Math.min(arr[s], r - i);
            } else {
                arr[i] = 0;
            }
            while (sstr.charAt(i + arr[i] + 1) == sstr.charAt(i - arr[i] - 1)) {
                ++arr[i];
            }
            
            if (i + arr[i] > r) {
                c = i;
                r = c + arr[c];
                if (maxLen < arr[c]) {
                    maxInd = c;
                    maxLen = arr[maxInd];          
                }
            }
            
            
        }
        int start = (maxInd - maxLen) / 2;
        int end = start + maxLen;
        return str.substring(start, end);
        
    }
}
```

